"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PubNubProvider = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@loopback/core");
const rest_1 = require("@loopback/rest");
const pubnub_1 = (0, tslib_1.__importDefault)(require("pubnub"));
const keys_1 = require("./keys");
let PubNubProvider = class PubNubProvider {
    constructor(pnConfig) {
        this.pnConfig = pnConfig;
        if (this.pnConfig) {
            this.pubnubService = new pubnub_1.default(this.pnConfig);
        }
        else {
            throw new rest_1.HttpErrors.PreconditionFailed('Pubnub Config missing !');
        }
    }
    value() {
        return {
            publish: async (message) => {
                if (message.receiver.to.length === 0) {
                    throw new rest_1.HttpErrors.BadRequest('Message receiver not found in request');
                }
                const publishes = message.receiver.to.map(receiver => {
                    var _a;
                    const publishConfig = {
                        channel: '',
                        message: {
                            title: message.subject,
                            description: message.body,
                            // eslint-disable-next-line @typescript-eslint/naming-convention
                            pn_gcm: {
                                data: Object.assign({
                                    title: message.subject,
                                    description: message.body,
                                }, message.options),
                            },
                            // eslint-disable-next-line @typescript-eslint/naming-convention
                            pn_apns: Object.assign({
                                aps: {
                                    alert: message.body,
                                    key: message.subject,
                                    sound: ((_a = message === null || message === void 0 ? void 0 : message.options) === null || _a === void 0 ? void 0 : _a.sound)
                                        ? message.options.sound
                                        : 'default',
                                },
                                // eslint-disable-next-line @typescript-eslint/naming-convention
                                pn_push: [
                                    {
                                        targets: [
                                            {
                                                environment: process.env.PUBNUB_APNS2_ENV,
                                                topic: process.env.PUBNUB_APNS2_BUNDLE_ID,
                                            },
                                        ],
                                        version: 'v2',
                                    },
                                ],
                            }, message.options),
                        },
                    };
                    if (receiver.type === 0 /* Channel */) {
                        publishConfig.channel = receiver.id;
                    }
                    return this.pubnubService.publish(publishConfig);
                });
                await Promise.all(publishes);
            },
            grantAccess: async (config) => {
                var _a;
                if (((_a = config.options) === null || _a === void 0 ? void 0 : _a.token) && config.options.ttl) {
                    const publishConfig = {
                        authKeys: [config.options.token],
                        channels: config.receiver.to.map(receiver => receiver.id),
                        read: config.options.allowRead || true,
                        write: config.options.allowWrite || false,
                        ttl: config.options.ttl,
                    };
                    await this.pubnubService.grant(publishConfig);
                    return {
                        ttl: config.options.ttl,
                    };
                }
                throw new rest_1.HttpErrors.BadRequest('Authorization token or ttl not found in request');
            },
            revokeAccess: async (config) => {
                var _a;
                if ((_a = config.options) === null || _a === void 0 ? void 0 : _a.token) {
                    const publishConfig = {
                        channels: config.receiver.to.map(receiver => receiver.id),
                        authKeys: [config.options.token],
                        read: false,
                        write: false,
                    };
                    await this.pubnubService.grant(publishConfig);
                    return {
                        success: true,
                    };
                }
                throw new rest_1.HttpErrors.BadRequest('Authorization token not found in request');
            },
        };
    }
};
PubNubProvider = (0, tslib_1.__decorate)([
    (0, tslib_1.__param)(0, (0, core_1.inject)(keys_1.PubnubBindings.Config, {
        optional: true,
    })),
    (0, tslib_1.__metadata)("design:paramtypes", [Object])
], PubNubProvider);
exports.PubNubProvider = PubNubProvider;
//# sourceMappingURL=pubnub.provider.js.map